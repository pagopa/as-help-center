<div class="lt-hero-unit lt-container">
    <div class="lt-container-inner lt-hero-unit__wrapper lt-d-flex lt-flex-column lt-flex-lg-row lt-justify-content-lg-between">
      <div class="lt-hero-unit__content new-requests lt-flex-lg-grow-1">
        {{!-- Title --}}
        <h1 class="lt-hero-unit__title lt-mb-3">
          {{t 'submit_a_request'}}
        </h1>
      </div>
    </div>
</div>

<div class="lt-container lt-new-request-page lt-pb-8 lt-pb-8 lt-pt-6 lt-pt-lg-8 lt-position-relative">
  <div class="lt-container-inner">
    <div class="lt-row">
      <div class="lt-col-md-8 lt-offset-md-2" id="main-content" role="main">

        <div class="lt-page-header lt-mb-8 lt-pb-2 new-request-header">
          <h2 class="lt-auth-user lt-fs-3">{{settings.new_request_hi_title}} {{user.name}}</h2>
          <h3 class="lt-auth-ask">{{settings.new_request_subtitle}}</h3>
        </div>

        <div id="contact_email_wrapper" class="lt-mb-4" style="opacity: 0;" role="status" aria-live="polite">
          <p class="email-contact-read-label">{{settings.new_request_email_label}} <span id="contact_email" class="email-contact-read"></span></p>
        </div>

        <!-- Screen reader only: loading announcement - a11y -->
        <div id="sr-loading-email" class="sr-only" aria-live="assertive" aria-atomic="true"></div>

        {{!-- <div class="lt-mb-6">
          <p class="lt-form-label request-new">{{settings.new_request_email_label}}</p>
          <label class="mdc-text-field extended mdc-text-field--outlined mdc-text-field--disabled">
            <span class="mdc-notched-outline">
              <span class="mdc-notched-outline__leading"></span>
              <span class="mdc-notched-outline__notch">
                <span class="mdc-floating-label" id="email-label">Email</span>
              </span>
              <span class="mdc-notched-outline__trailing"></span>
            </span>
            <input type="text" class="mdc-text-field__input"
                 aria-labelledby="email-label" id="email"
                 name="email" value="test@email.com" disabled>
          </label>
        </div> --}}

        <div class="lt-new-request-form">
            {{request_form }}
        </div>

      </div>
    </div>
  </div>
</div>

<script type="module">
  // Transform form inputs to material design components
  window.addEventListener('DOMContentLoaded', () => {
    const form = document.querySelector('.lt-new-request-form form');
    if (!form) return;

    // Get current user and display email
    const loadingSpinner = $('#loading-spinner');
    // a11y
    const srLoadingAnnouncement = document.getElementById('sr-loading-email');
    
    loadingSpinner.removeClass('lt-d-none');
    // a11y
    if (srLoadingAnnouncement) {
      srLoadingAnnouncement.textContent = 'Caricamento informazioni utente in corso';
    }
    
    LotusUtils.getCurrentUser((error, user) => {
      const emailWrapper = document.getElementById('contact_email_wrapper');
      const emailSpan = document.getElementById('contact_email');
      
      // Hide loading spinner
      if (loadingSpinner) {
        loadingSpinner.delay(200).fadeOut();
      }
      
      if (!error && user && user.email) {
        // Show wrapper and update email if available
        if (emailSpan) {
          emailSpan.textContent = user.email;
        }
        if (emailWrapper) {
          $(emailWrapper).fadeTo(400, 1);
        }
        // a11y
        if (srLoadingAnnouncement) {
          srLoadingAnnouncement.textContent = 'Email caricata: ' + user.email;
          // Clear after announcement
          setTimeout(() => { srLoadingAnnouncement.textContent = ''; }, 1000);
        }
      }
      // If no email, wrapper stays hidden
    });
    
    // Hide request_subject field
    const subjectField = form.querySelector('.form-field.string.request_subject');
    if (subjectField) {
      subjectField.classList.add('hidden');
      // a11y
      subjectField.setAttribute('aria-hidden', 'true');
      const inputs = subjectField.querySelectorAll('input, select, textarea');
      inputs.forEach(input => input.setAttribute('tabindex', '-1'));
    }

    // Hide org field and select _users_hc_cac
    const orgSelector = form.querySelector('.form-field.request_organization_id a');
    if (orgSelector) {
      orgSelector.click();
      const org_to_be_selected = '_users_hc_cac';
      const org_option_id = orgSelector.getAttribute("aria-controls");
      const items = document.querySelectorAll(`#${org_option_id} li`);
      items.forEach(function(item) {
      if (item.textContent.trim() === org_to_be_selected) {
          item.click();
      }
      });
      const orgContainer = form.querySelector('.form-field.request_organization_id');
      orgContainer.classList.add('hidden');
    }

    // transform submit buttons
    try {
      const submits = form.querySelectorAll('input[type="submit"], button[type="submit"]');
      submits.forEach((btn) => {
        btn.className = 'lt-btn lt-btn--square lt-btn--outline';
        btn.value = "{{settings.new_request_submit_label}}";
      });
    } catch (err) {
      // ignore
    }

    // Function to transform a single text input into MDC text field
    const transformTextInput = (input) => {
      // Skip if already wrapped
      if (input.closest('.mdc-text-field')) return;
      
      // Skip if original input has display: none
      const computedStyle = window.getComputedStyle(input);
      if (computedStyle.display === 'none' || input.style.display === 'none') return;

      // Get original label if present
      const originalLabel = input.previousElementSibling?.tagName === 'LABEL' ? input.previousElementSibling : null;
      const labelText = originalLabel ? originalLabel.textContent.trim() : (input.getAttribute('placeholder') || '');
      const labelId = input.id ? `${input.id}-label` : `label-${Math.random().toString(36).substr(2, 9)}`;

      // Create static label above input
      const staticLabel = document.createElement('p');
      staticLabel.className = 'lt-form-label request-new';
      staticLabel.style.cssText = 'margin:0 0 1rem 0; font-weight:600; font-size: 18px';
      staticLabel.textContent = labelText;
      staticLabel.id = labelId;

      // Create MDC wrapper structure
      const mdcLabel = document.createElement('label');
      mdcLabel.className = 'mdc-text-field extended mdc-text-field--outlined';
      
      // Add disabled class only if input is actually disabled
      if (input.disabled || input.hasAttribute('disabled')) {
        mdcLabel.classList.add('mdc-text-field--disabled');
      }

      const outline = document.createElement('span');
      outline.className = 'mdc-notched-outline';

      const leading = document.createElement('span');
      leading.className = 'mdc-notched-outline__leading';

      const trailing = document.createElement('span');
      trailing.className = 'mdc-notched-outline__trailing';

      outline.appendChild(leading);
      outline.appendChild(trailing);
      mdcLabel.appendChild(outline);

      // Update input classes and attributes
      input.classList.add('mdc-text-field__input');
      input.setAttribute('aria-labelledby', labelId);
      
      // a11y - Add aria-required if input is required
      if (input.required || input.hasAttribute('required')) {
        input.setAttribute('aria-required', 'true');
      }
      
      // Remove original label if exists
      if (originalLabel) {
        originalLabel.remove();
      }

      // Insert MDC wrapper before input and move input inside
      input.parentNode.insertBefore(staticLabel, input);
      input.parentNode.insertBefore(mdcLabel, input);
      mdcLabel.appendChild(input);

      // Initialize MDC component
      try {
        if (window.mdc && window.mdc.textField) {
          mdc.textField.MDCTextField.attachTo(mdcLabel);
        }
      } catch (e) {
        console.error('MDC init error:', e);
      }
    };

    // Find all text inputs that need MDC wrapping (exclude hidden, checkbox, radio, file, submit)
    const textInputs = form.querySelectorAll('input[type="text"], input[type="email"], input[type="tel"], input[type="url"], input[type="number"], input:not([type])');
    textInputs.forEach(transformTextInput);

    // Also handle existing .mdc-text-field that might be already in the form
    document.querySelectorAll('.mdc-text-field').forEach((el) => {
      try {
        if (window.mdc && window.mdc.textField) {
          mdc.textField.MDCTextField.attachTo(el);
        }
      } catch (e) {
        // already initialized or error
      }
    });

    // Transform textarea elements into MDC textarea
    const transformTextAreaInput = (textarea) => {
      // Skip if already wrapped
      if (textarea.closest('.mdc-text-field')) return;

      // Add placeholder for request description textarea
      if (textarea.name === 'request[description]') {
        textarea.setAttribute('placeholder', "{{settings.new_request_details_ph}}");
      }

      // Get original label if present
      const container = textarea.closest('.form-field');
      const originalLabel = container ? container.querySelector('label') : null;
      const labelText = originalLabel ? originalLabel.textContent.trim() : (textarea.getAttribute('aria-label') || '');
      const labelId = textarea.id ? `${textarea.id}-label` : `label-${Math.random().toString(36).substr(2, 9)}`;

      // Create static label above textarea
      const staticLabel = document.createElement('p');
      staticLabel.className = 'lt-form-label request-new';
      staticLabel.style.cssText = 'margin:0 0 1rem 0; font-weight:600; font-size: 18px';
      staticLabel.textContent = labelText;
      staticLabel.id = labelId;

      // Create MDC textarea wrapper structure
      const mdcLabel = document.createElement('label');
      mdcLabel.className = 'mdc-text-field extended mdc-text-field--outlined mdc-text-field--textarea mdc-text-field--no-label';

      const outline = document.createElement('span');
      outline.className = 'mdc-notched-outline';

      const leading = document.createElement('span');
      leading.className = 'mdc-notched-outline__leading';

      const trailing = document.createElement('span');
      trailing.className = 'mdc-notched-outline__trailing';

      const resizer = document.createElement('span');
      resizer.className = 'mdc-text-field__resizer';

      outline.appendChild(leading);
      outline.appendChild(trailing);
      mdcLabel.appendChild(outline);

      // Update textarea classes and attributes
      textarea.classList.add('mdc-text-field__input');
      textarea.setAttribute('aria-labelledby', labelId);
      
      // a11y - Add aria-required if textarea is required
      if (textarea.required || textarea.hasAttribute('required')) {
        textarea.setAttribute('aria-required', 'true');
      }
      
      // Set textarea size (rows)
      if (!textarea.hasAttribute('rows')) {
        textarea.setAttribute('rows', '6');
      }
      
      // Remove original label if exists
      if (originalLabel) {
        originalLabel.style.display = 'none';
      }

      // Insert static label and MDC wrapper before textarea
      textarea.parentNode.insertBefore(staticLabel, textarea);
      textarea.parentNode.insertBefore(mdcLabel, textarea);
      
      // Move textarea inside resizer, then resizer inside mdcLabel
      resizer.appendChild(textarea);
      mdcLabel.appendChild(resizer);

      // Initialize MDC component
      try {
        if (window.mdc && window.mdc.textField) {
          mdc.textField.MDCTextField.attachTo(mdcLabel);
        }
      } catch (e) {
        console.error('MDC textarea init error:', e);
      }
    };
    const textareas = form.querySelectorAll('textarea');
    textareas.forEach(transformTextAreaInput);

    // Transform file input for attachments
    const uploadDropzone = form.querySelector('#upload-dropzone');
    const fileInput = form.querySelector('#request-attachments');
    
    if (uploadDropzone && fileInput) {
      // Update attachments label text
      const attachmentsLabel = form.querySelector('label[for="request-attachments"]');
      if (attachmentsLabel) {
        attachmentsLabel.innerHTML = "{{settings.new_request_attachments_label}}";
      }

      // Hide the original dropzone text
      const dropzoneText = uploadDropzone.querySelector('span');
      if (dropzoneText) {
        dropzoneText.style.display = 'none';
      }

      // Create custom button
      const customBtn = document.createElement('button');
      customBtn.type = 'button';
      customBtn.className = 'lt-btn lt-btn--square lt-btn--outline';
      customBtn.innerHTML = '<i class="fa-solid fa-circle-plus lt-me-2" aria-hidden="true"></i>' + "{{settings.new_request_attachments_btn}}";
      
      // Insert custom button inside the dropzone
      uploadDropzone.insertBefore(customBtn, uploadDropzone.firstChild);

      // Trigger file input when custom button is clicked
      customBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        fileInput.click();
      });

      // a11y - Create screen reader announcement area for file upload
      const srFileAnnouncement = document.createElement('div');
      srFileAnnouncement.className = 'sr-only';
      srFileAnnouncement.setAttribute('aria-live', 'polite');
      srFileAnnouncement.setAttribute('aria-atomic', 'true');
      uploadDropzone.appendChild(srFileAnnouncement);

      // Add aria-describedby to file input
      if (attachmentsLabel) {
        const labelId = 'file-upload-description';
        attachmentsLabel.id = labelId;
        fileInput.setAttribute('aria-describedby', labelId);
      }

      // Announce selected file names to screen readers
      fileInput.addEventListener('change', () => {
        const files = Array.from(fileInput.files);
        if (files.length > 0) {
          const fileNames = files.map(f => f.name).join(', ');
          // a11y
          srFileAnnouncement.textContent = `${files.length} file: ${fileNames}`;
        } else {
          // a11y
          srFileAnnouncement.textContent = 'Nessun file selezionato';
        }
      });
    }

    // Transform select field (nesty-input) into MDC Select
    const transformCustomFieldSelect = (container) => {
      const hiddenInput = container.querySelector('input[type="hidden"][data-tagger]');
      const nestyInput = container.querySelector('.nesty-input');
      const originalLabel = container.querySelector('label');
      
      if (!hiddenInput || !nestyInput || !originalLabel) return;
      
      // Skip if already transformed
      if (container.querySelector('.mdc-select')) return;
      
      // Parse tagger data to get options
      let options = [];
      try {
        const taggerData = hiddenInput.getAttribute('data-tagger');
        options = JSON.parse(taggerData);
        
        // Filter out unwanted options
        const hiddenValuesString = "{{settings.new_request_hidden_options}}";
        const hiddenValues = hiddenValuesString.split(';').map(s => s.trim());
        options = options.filter(opt => !hiddenValues.includes(opt.value));
      } catch (e) {
        console.error('Failed to parse tagger data:', e);
        return;
      }
      
      // Get label text and IDs
      const labelText = originalLabel.textContent.trim();
      const labelId = `${hiddenInput.id}-mdc-label`;
      const selectId = `mdc-select-${hiddenInput.id}`;
      
      // Create static label above the select
      const staticLabel = document.createElement('p');
      staticLabel.className = 'lt-form-label request-new';
      staticLabel.textContent = labelText;
      staticLabel.id = labelId;
      
      // Create MDC Select structure (without floating label in notch)
      const mdcSelect = document.createElement('div');
      mdcSelect.className = 'mdc-select extended mdc-select--outlined';
      mdcSelect.id = selectId;
      
      const anchor = document.createElement('div');
      anchor.className = 'mdc-select__anchor';
      anchor.setAttribute('aria-labelledby', labelId);
      
      const outline = document.createElement('span');
      outline.className = 'mdc-notched-outline';
      
      const leading = document.createElement('span');
      leading.className = 'mdc-notched-outline__leading';
      
      const notch = document.createElement('span');
      notch.className = 'mdc-notched-outline__notch';
      // No floating label inside notch
      
      const trailing = document.createElement('span');
      trailing.className = 'mdc-notched-outline__trailing';
      
      const selectedTextContainer = document.createElement('span');
      selectedTextContainer.className = 'mdc-select__selected-text-container';
      
      const selectedText = document.createElement('span');
      selectedText.className = 'mdc-select__selected-text';
      selectedText.id = `${selectId}-selected-text`;
      
      const dropdownIcon = document.createElement('span');
      dropdownIcon.className = 'mdc-select__dropdown-icon';
      dropdownIcon.innerHTML = `
        <svg class="mdc-select__dropdown-icon-graphic" viewBox="7 10 10 5" focusable="false">
          <polygon class="mdc-select__dropdown-icon-inactive" stroke="none" fill-rule="evenodd" points="7 10 12 15 17 10"></polygon>
          <polygon class="mdc-select__dropdown-icon-active" stroke="none" fill-rule="evenodd" points="7 15 12 10 17 15"></polygon>
        </svg>
      `;
      
      // Build menu
      const menu = document.createElement('div');
      menu.className = 'mdc-select__menu mdc-menu mdc-menu-surface mdc-menu-surface--fullwidth';
      
      const list = document.createElement('ul');
      list.className = 'mdc-list';
      list.setAttribute('role', 'listbox');
      list.setAttribute('aria-label', labelText);
      
      // Find default option (first one or empty value)
      let defaultOption = options[0];
      
      // Populate list items from options
      options.forEach((option, index) => {
        const listItem = document.createElement('li');
        listItem.className = 'mdc-list-item';
        listItem.setAttribute('data-value', option.value);
        listItem.setAttribute('role', 'option');
        
        // Select first option by default
        if (index === 0) {
          listItem.classList.add('mdc-list-item--selected');
          listItem.setAttribute('aria-selected', 'true');
          selectedText.textContent = option.label;
        } else {
          listItem.setAttribute('aria-selected', 'false');
        }
        
        const ripple = document.createElement('span');
        ripple.className = 'mdc-list-item__ripple';
        
        const text = document.createElement('span');
        text.className = 'mdc-list-item__text';
        text.textContent = option.label;
        
        listItem.appendChild(ripple);
        listItem.appendChild(text);
        list.appendChild(listItem);
      });
      
      // Assemble structure
      outline.appendChild(leading);
      outline.appendChild(notch);
      outline.appendChild(trailing);
      
      selectedTextContainer.appendChild(selectedText);
      
      anchor.appendChild(outline);
      anchor.appendChild(selectedTextContainer);
      anchor.appendChild(dropdownIcon);
      
      menu.appendChild(list);
      
      mdcSelect.appendChild(anchor);
      mdcSelect.appendChild(menu);
      
      // Hide original elements
      nestyInput.style.display = 'none';
      originalLabel.style.display = 'none';
      
      // Insert static label and MDC select before hidden input
      container.insertBefore(staticLabel, hiddenInput);
      container.insertBefore(mdcSelect, hiddenInput);
      
      // Initialize MDC Select and sync with hidden input
      try {
        if (window.mdc && window.mdc.select) {
          const mdcSelectInstance = mdc.select.MDCSelect.attachTo(mdcSelect);
          
          // Set default value (first option, usually "-")
          if (defaultOption) {
            mdcSelectInstance.value = defaultOption.value;
            hiddenInput.value = defaultOption.value;
          }
          
          // Sync selection with hidden input
          mdcSelectInstance.listen('MDCSelect:change', () => {
            hiddenInput.value = mdcSelectInstance.value;
            // Trigger change event on hidden input for any validation logic
            hiddenInput.dispatchEvent(new Event('change', { bubbles: true }));
          });
        }
      } catch (e) {
        console.error('MDC Select init error:', e);
      }
    };

    // Transform all existing custom field selects
    const customFieldContainers = form.querySelectorAll('.form-field.string.required, .form-field.string');
    customFieldContainers.forEach(transformCustomFieldSelect);

    // Watch for dynamically added fields and attribute changes (for conditional fields)
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        // Handle attribute changes (when Zendesk removes 'hidden' or 'disabled')
        if (mutation.type === 'attributes') {
          const target = mutation.target;
          
          // If a form-field container is no longer hidden, transform its fields
          if (mutation.attributeName === 'hidden' && target.classList && target.classList.contains('form-field')) {
            if (!target.hasAttribute('hidden')) {
              // Container is now visible, transform its inputs
              transformCustomFieldSelect(target);
              
              const inputs = target.querySelectorAll('input[type="text"], input[type="email"], input[type="tel"], input[type="url"], input[type="number"]');
              inputs.forEach(transformTextInput);
              
              const textareas = target.querySelectorAll('textarea');
              textareas.forEach(transformTextAreaInput);
            }
          }
          
          // If an input's disabled attribute changes, update the MDC wrapper
          if (mutation.attributeName === 'disabled') {
            const input = target;
            const mdcWrapper = input.closest('.mdc-text-field');
            
            if (mdcWrapper) {
              if (input.disabled || input.hasAttribute('disabled')) {
                mdcWrapper.classList.add('mdc-text-field--disabled');
              } else {
                mdcWrapper.classList.remove('mdc-text-field--disabled');
              }
            }
          }
        }
        
        // Handle added nodes
        mutation.addedNodes.forEach((node) => {
          if (node.nodeType === 1) { // Element node
            // Transform select fields
            if (node.classList && node.classList.contains('form-field')) {
              transformCustomFieldSelect(node);
            }
            // Check if any descendants are form-fields (selects)
            if (node.querySelectorAll) {
              const newSelectFields = node.querySelectorAll('.form-field.string.required, .form-field.string');
              newSelectFields.forEach(transformCustomFieldSelect);
              
              // Transform text inputs
              const newTextInputs = node.querySelectorAll('input[type="text"], input[type="email"], input[type="tel"], input[type="url"], input[type="number"], input:not([type])');
              newTextInputs.forEach(transformTextInput);
              
              // Transform textareas
              const newTextareas = node.querySelectorAll('textarea');
              newTextareas.forEach(transformTextAreaInput);
            }
          }
        });
      });
    });

    // Start observing the form for changes (both DOM changes and attribute changes)
    observer.observe(form, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['hidden', 'disabled']
    });
  });
</script>
